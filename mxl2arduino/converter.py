import sys
import os
import xml.etree.ElementTree as ET
from zipfile import ZipFile
import tempfile

class Converter:
    durationValues = {'whole': 4, 'half': 2, 'quarter': 1, 'eighth': 0.5, '16th': 0.25}
    steps = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'A']

    def convertXML(self, file):
        root = ET.parse(file).getroot()
        
        notes, durations = self.getNotes(root)
        title = root.find('work/work-title').text if not root.find('work/work-title') is None else ''
        content, headerContent = self.generateContent(notes, durations, title)
        self.writeFiles(content, headerContent)

    def getNotes(self, root):
        divisions = int(root.find('part/measure/attributes/divisions').text)
        sound = root.find('part/measure/direction/sound')
        staves = root.find('part/measure/attributes/staves')
        staves = int(staves.text) if not staves is None else 1

        if staves > 1:
            notes = [[] for i in range(staves)]
            durations = [[] for i in range(staves)]
        else:
            notes = []
            durations = []

        if not sound is None:
            tempo = int(sound.get('tempo'))
        else:
            tempo = 120
        
        quarterNote = 60.0 / tempo / divisions * 1000.0

        for measure in root.findall('part/measure'):
            for note in measure.findall('note'):
                if note.find('rest') is None:
                    noteName = 'NOTE_'
                    if not note.find('pitch/alter') is None:
                        if int(note.find('pitch/alter').text) == 1:
                            noteName += note.find('pitch/step').text + 'S'
                        elif int(note.find('pitch/alter').text) == -1:
                            index = self.steps[1:].index(note.find('pitch/step').text.upper())
                            noteName += self.steps[index-1] + 'S'
                    else:
                        noteName += note.find('pitch/step').text
                    noteName += note.find('pitch/octave').text
                else:
                    noteName = '0'

                if not note.find('duration') is None:
                    duration = quarterNote * int(note.find('duration').text)
                else:
                    noteType = note.find('type')
                    if not noteType is None and noteType.text in self.durationValues:
                        duration = quarterNote * self.durationValues[noteType.text]
                    else:
                        duration = quarterNote * 4

                if staves > 1:
                    index = int(note.find('staff').text)-1
                    notes[index].append(noteName)
                    durations[index].append(round(duration))
                else:
                    notes.append(noteName)
                    durations.append(round(duration))
        return (notes, durations)

    def generateContent(self, notes, durations, title):
        content = '#include "melody.h"\n\n/* '+title+' \n'
        content += 'Generated by MusicXML to Arduino \nhttps://github.com/grze2000/MusicXML-to-Arduino */\n\n'
        headerContent = '#ifndef melody_h\n#define melody_h\n#include "pitches.h"\n\n'
        if isinstance(notes[0], list):
            for i in range(len(notes)):
                content += 'int notes' + (str(i+1) if i != 0 else '') + '[' + str(len(notes[i])) + '] = {' + ', '.join(notes[i]) + '};\n'
                content += 'int durations' + (str(i+1) if i != 0 else '') + '[' + str(len(durations[i])) + '] = {' + ', '.join(list(map(str, durations[i]))) + '};\n\n'
                
                headerContent += 'extern int notes' + (str(i+1) if i != 0 else '') + '[' + str(len(notes[i])) + '];\n'
                headerContent += 'extern int durations' + (str(i+1) if i != 0 else '') + '[' + str(len(durations[i])) + '];\n\n'
        else:
            content += 'int notes[' + str(len(notes)) + '] = {' + (', '.join(notes)) + '};\n\n'
            content += 'int durations[' + str(len(durations)) + '] = {' + (', '.join(list(map(str, durations)))) + '};'

            headerContent += 'extern int notes[' + str(len(notes)) + '];\nextern int durations[' + str(len(durations)) + '];\n\n'

        headerContent += '#endif'
        return (content, headerContent)

    def writeFiles(self, content, headerContent):
        with open(os.path.join(self.outputDir, 'melody.cpp'), 'w', encoding='utf8') as file:
            file.write(content)
            file.close()

        with open(os.path.join(self.outputDir, 'melody.h'), 'w', encoding='utf8') as headerFile:
            headerFile.write(headerContent)
            headerFile.close()

    def convertMXL(self, file):
        with tempfile.TemporaryDirectory() as tmpDir:
            with ZipFile(file, 'r') as mxl:
                mxl.extractall(tmpDir)
                for file in os.listdir(tmpDir):
                    if file.endswith('.xml'):
                        return self.convertXML(os.path.join(tmpDir, file))
                raise FileNotFoundError('.xml file not found')

    def convert(self, inputFile, outputDir):
        self.outputDir = outputDir
        if not os.path.exists(inputFile):
            raise FileNotFoundError(f"{inputFile} doesn't exist")

        if not os.path.isdir(outputDir):
            raise FileNotFoundError(f"Directory {outputDir} doesn't exist")

        if inputFile.endswith('.xml'):
            self.convertXML(inputFile)
        elif inputFile.endswith('.mxl'):
            self.convertMXL(inputFile)
        else:
            raise ValueError(f"Invalid file type: .{inputFile.split('.')[-1]}. Expected .xml or .xml")

